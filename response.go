package hat

import (
	"bytes"
	"encoding/json"
	"io/ioutil"
	"net/http"
	"net/http/httputil"
)

// ResponseAssertion requires a quality of the response.
type ResponseAssertion func(t *T, r Response)

// CombineResponseAssertions returns a new ResponseAssertion which internally
// calls each member of requires in the provided order.
func CombineResponseAssertions(as ...ResponseAssertion) ResponseAssertion {
	return func(t *T, r Response) {
		t.Helper()
		r.Assert(t, as...)
	}
}

// Response represents an HTTP response generated by hat.Request.
type Response struct {
	*http.Response
}

// Assert runs each requireion against the response.
// It closes the response body after all of the requireions have ran.
// Assert must be called for every response as it will ensure the body is closed.
// If you want to continue to reuse the connection, you must read the response body.
func (r Response) Assert(t *T, assertions ...ResponseAssertion) Response {
	t.Helper()
	defer r.Body.Close()

	for _, a := range assertions {
		a(t, r)
		if t.Failed() {
			header, _ := httputil.DumpResponse(r.Response, false)

			t.Errorf("resp:\n%s", header)

			body := r.DuplicateBody(t)
			fmted := &bytes.Buffer{}
			err := json.Indent(fmted, body, "", "  ")
			if err == nil {
				body = fmted.Bytes()
			}

			t.Logf("body:\n%s", body)

			t.FailNow()
		}
	}

	return r
}

// DuplicateBody reads in the response body.
// It replaces the underlying body with a duplicate.
func (r Response) DuplicateBody(t *T) []byte {
	defer r.Body.Close()

	byt, err := ioutil.ReadAll(r.Body)
	if err != nil {
		t.Fatalf("failed to read body: %v", err)
	}

	r.Response.Body = ioutil.NopCloser(bytes.NewReader(byt))

	return byt
}
